{"ast":null,"code":"/**\n *  This file gets the solved sudoku from 'sudoku.js' and\n * generates a unique sudoku position from it.\n *\n *  Initially, I tried the sudokus generated by 'sudoku.js'. But\n * it didnt handle the difficulty properly. An 'Easy' sudoku is\n * not that easy, and can be quite hard sometimes! And, filling\n * is uneven. Sometimes, entire rows/columns/boxes are filled!\n *\n *  The 'sudoku.js' code is untouched, except for the minimal\n * changes required to import it here.\n *\n *  The 'sudoku.js' javascript library by robatron is at\n * https://github.com/robatron/sudoku.js . All credits to\n * robatron for taking the hustle out of creating valid sudokus!\n *\n *  My code in this module builds on his code! This wouldn't\n * be possible without people like him sharing in the\n * open source community!\n */\nimport { getSudoku } from './sudoku';\n\n/**\n * The Sudoku position is 9x9.\n *    A1 A2 A3 A4 A5 A6 A7 A8 A9\n *    B1 B2 B3 B4 B5 B6 B7 B8 B9\n *    C1 C2 C3 C4 C5 C6 C7 C8 C9\n *    D1 D2 D3 D4 D5 D6 D7 D8 D9\n *    E1 E2 E3 E4 E5 E6 E7 E8 E9\n *    F1 F2 F3 F4 F5 F6 F7 F8 F9\n *    G1 G2 G3 G4 G5 G6 G7 G8 G9\n *    H1 H2 H3 H4 H5 H6 H7 H8 H9\n *    I1 I2 I3 I4 I5 I6 I7 I8 I9\n *\n * It can be considered to be comprised of 9 boxes\n * each, stacked in a 3x3 formation.\n * Like this: Box1 Box2 Box3\n *            Box4 Box5 Box6\n *            Box7 Box8 Box9\n *\n * In turn, each box is comprised of 9 cells stacked\n * in a 3x3 formation as above. This gives us the below\n * representation:\n *      Box1        Box2        Box3\n *    A1 A2 A3    A4 A5 A6    A7 A8 A9\n *    B1 B2 B3    B4 B5 B6    B7 B8 B9\n *    C1 C2 C3    C4 C5 C6    C7 C8 C9\n *      Box4        Box5        Box6\n *    D1 D2 D3    D4 D5 D6    D7 D8 D9\n *    E1 E2 E3    E4 E5 E6    E7 E8 E9\n *    F1 F2 F3    F4 F5 F6    F7 F8 F9\n *      Box7        Box8        Box9\n *    G1 G2 G3    G4 G5 G6    G7 G8 G9\n *    H1 H2 H3    H4 H5 H6    H7 H8 H9\n *    I1 I2 I3    I4 I5 I6    I7 I8 I9\n *\n * For example, Box1 has the following cells:\n * Box1: A1 A2 A3\n *       B1 B2 B3\n *       C1 C2 C3\n *\n * So in Box1,\n *    Cell1: A1   Cell2: A2   Cell3: A3\n *    Cell4: B1   Cell5: B2   Cell6: B3\n *    Cell7: C1   Cell8: C2   Cell9: C3\n *\n * and in Box8,\n *    Cell1: G4   Cell2: G5   Cell3: G6\n *    Cell4: H4   Cell5: H5   Cell6: H6\n *    Cell7: I4   Cell8: I5   Cell9: I6\n *\n * and so on...\n */\n\n/**\n * Initializes a null array for easier resets in the code.\n */\nlet nullArray = ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'];\n\n/**\n * Gets the coordinates of the center cell of the specified box.\n */\nfunction _getBoxCenter(box) {\n  // eslint-disable-next-line\n  switch (box) {\n    case 0:\n      return [1, 1];\n    case 1:\n      return [1, 4];\n    case 2:\n      return [1, 7];\n    case 3:\n      return [4, 1];\n    case 4:\n      return [4, 4];\n    case 5:\n      return [4, 7];\n    case 6:\n      return [7, 1];\n    case 7:\n      return [7, 4];\n    default:\n      return [7, 7];\n  }\n}\n\n/**\n * Gets the index of cell given:\n * 1. Box\n * 2. Cell\n */\nfunction _getIndexOfCell(box, cell) {\n  let [row, column] = _getBoxCenter(box);\n  // eslint-disable-next-line\n  switch (cell) {\n    case 0:\n      {\n        row--;\n        column--;\n        break;\n      }\n    case 1:\n      {\n        row--;\n        break;\n      }\n    case 2:\n      {\n        row--;\n        column++;\n        break;\n      }\n    case 3:\n      {\n        column--;\n        break;\n      }\n    case 4:\n      {\n        break;\n      }\n    case 5:\n      {\n        column++;\n        break;\n      }\n    case 6:\n      {\n        row++;\n        column--;\n        break;\n      }\n    case 7:\n      {\n        row++;\n        break;\n      }\n    case 8:\n      {\n        row++;\n        column++;\n        break;\n      }\n  }\n  return row * 9 + column;\n}\n\n/**\n * Checks if Cell is available or not (i.e., filled).\n */\nfunction _cellAvailable(tempInitArray, box, value) {\n  return tempInitArray[_getIndexOfCell(box, value)] === '0' ? 0 : 1;\n}\n\n/**\n * Generates a Unique Sudoku puzzle from a solved Sudoku.\n */\nfunction _generateUniqueSudoku(solvedArray, difficulty, e) {\n  let currentDifficulty = difficulty;\n  let minimumCells, maximumCells, totalCells, box, cell;\n  let tempInitArray = nullArray.slice();\n  let boxCounts = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n  let boxesAvailable = [];\n  let cellsAvailable = [];\n  if (e) currentDifficulty = e.target.value;\n  if (currentDifficulty === 'Easy') {\n    minimumCells = 3;\n    maximumCells = 7;\n    totalCells = 45;\n  } else if (currentDifficulty === 'Medium') {\n    minimumCells = 2;\n    maximumCells = 6;\n    totalCells = 40;\n  } else {\n    minimumCells = 1;\n    maximumCells = 5;\n    totalCells = 30;\n  }\n  for (let j = 0; j < 9; j++) {\n    boxCounts[j] = _cellAvailable(tempInitArray, j, 0) + _cellAvailable(tempInitArray, j, 1) + _cellAvailable(tempInitArray, j, 2) + _cellAvailable(tempInitArray, j, 3) + _cellAvailable(tempInitArray, j, 4) + _cellAvailable(tempInitArray, j, 5) + _cellAvailable(tempInitArray, j, 6) + _cellAvailable(tempInitArray, j, 7) + _cellAvailable(tempInitArray, j, 8);\n  }\n  for (let i = 0; i < totalCells; i++) {\n    boxesAvailable = [];\n    for (let j = 0; j < 9; j++) {\n      if (boxCounts[j] < minimumCells) {\n        boxesAvailable.push(j);\n      }\n    }\n    if (boxesAvailable) {\n      for (let j = 0; j < 9; j++) {\n        if (boxCounts[j] < maximumCells) {\n          boxesAvailable.push(j);\n        }\n      }\n    }\n    box = boxesAvailable[Math.random() * boxesAvailable.length | 0];\n    cellsAvailable = [];\n    for (let j = 0; j < 9; j++) {\n      if (tempInitArray[_getIndexOfCell(box, j)] === '0') {\n        cellsAvailable.push(j);\n      }\n    }\n    cell = cellsAvailable[Math.random() * cellsAvailable.length | 0];\n    let index = _getIndexOfCell(box, cell);\n    tempInitArray[index] = solvedArray[index];\n    boxCounts[box]++;\n  }\n  return tempInitArray;\n}\nexport const getUniqueSudoku = (difficulty, e) => {\n  let temporaryInitArray = nullArray.slice();\n  let temporarySolvedArray = nullArray.slice();\n  let sudoku = getSudoku();\n\n  /**\n   * Get Sudoku from sudoku.js\n   */\n  let str = sudoku.generate(60);\n  [...str].forEach((value, index) => {\n    temporaryInitArray[index] = value === '.' ? '0' : value;\n  });\n\n  /**\n   * Get the solution from sudoku.js\n   */\n  str = sudoku.solve(str);\n  [...str].forEach((value, index) => {\n    temporarySolvedArray[index] = value;\n  });\n\n  /**\n   * Pass the generated solution and get a unique Sudoku from it!\n   */\n  temporaryInitArray = _generateUniqueSudoku(temporarySolvedArray, difficulty, e);\n  return [temporaryInitArray, temporarySolvedArray];\n};","map":{"version":3,"names":["getSudoku","nullArray","_getBoxCenter","box","_getIndexOfCell","cell","row","column","_cellAvailable","tempInitArray","value","_generateUniqueSudoku","solvedArray","difficulty","e","currentDifficulty","minimumCells","maximumCells","totalCells","slice","boxCounts","boxesAvailable","cellsAvailable","target","j","i","push","Math","random","length","index","getUniqueSudoku","temporaryInitArray","temporarySolvedArray","sudoku","str","generate","forEach","solve"],"sources":["/Users/robiokidenis/Projects/Game/sudoku-react/src/solver/UniqueSudoku.tsx"],"sourcesContent":["/**\n *  This file gets the solved sudoku from 'sudoku.js' and\n * generates a unique sudoku position from it.\n *\n *  Initially, I tried the sudokus generated by 'sudoku.js'. But\n * it didnt handle the difficulty properly. An 'Easy' sudoku is\n * not that easy, and can be quite hard sometimes! And, filling\n * is uneven. Sometimes, entire rows/columns/boxes are filled!\n *\n *  The 'sudoku.js' code is untouched, except for the minimal\n * changes required to import it here.\n *\n *  The 'sudoku.js' javascript library by robatron is at\n * https://github.com/robatron/sudoku.js . All credits to\n * robatron for taking the hustle out of creating valid sudokus!\n *\n *  My code in this module builds on his code! This wouldn't\n * be possible without people like him sharing in the\n * open source community!\n */\nimport { getSudoku } from './sudoku';\n\n/**\n * The Sudoku position is 9x9.\n *    A1 A2 A3 A4 A5 A6 A7 A8 A9\n *    B1 B2 B3 B4 B5 B6 B7 B8 B9\n *    C1 C2 C3 C4 C5 C6 C7 C8 C9\n *    D1 D2 D3 D4 D5 D6 D7 D8 D9\n *    E1 E2 E3 E4 E5 E6 E7 E8 E9\n *    F1 F2 F3 F4 F5 F6 F7 F8 F9\n *    G1 G2 G3 G4 G5 G6 G7 G8 G9\n *    H1 H2 H3 H4 H5 H6 H7 H8 H9\n *    I1 I2 I3 I4 I5 I6 I7 I8 I9\n *\n * It can be considered to be comprised of 9 boxes\n * each, stacked in a 3x3 formation.\n * Like this: Box1 Box2 Box3\n *            Box4 Box5 Box6\n *            Box7 Box8 Box9\n *\n * In turn, each box is comprised of 9 cells stacked\n * in a 3x3 formation as above. This gives us the below\n * representation:\n *      Box1        Box2        Box3\n *    A1 A2 A3    A4 A5 A6    A7 A8 A9\n *    B1 B2 B3    B4 B5 B6    B7 B8 B9\n *    C1 C2 C3    C4 C5 C6    C7 C8 C9\n *      Box4        Box5        Box6\n *    D1 D2 D3    D4 D5 D6    D7 D8 D9\n *    E1 E2 E3    E4 E5 E6    E7 E8 E9\n *    F1 F2 F3    F4 F5 F6    F7 F8 F9\n *      Box7        Box8        Box9\n *    G1 G2 G3    G4 G5 G6    G7 G8 G9\n *    H1 H2 H3    H4 H5 H6    H7 H8 H9\n *    I1 I2 I3    I4 I5 I6    I7 I8 I9\n *\n * For example, Box1 has the following cells:\n * Box1: A1 A2 A3\n *       B1 B2 B3\n *       C1 C2 C3\n *\n * So in Box1,\n *    Cell1: A1   Cell2: A2   Cell3: A3\n *    Cell4: B1   Cell5: B2   Cell6: B3\n *    Cell7: C1   Cell8: C2   Cell9: C3\n *\n * and in Box8,\n *    Cell1: G4   Cell2: G5   Cell3: G6\n *    Cell4: H4   Cell5: H5   Cell6: H6\n *    Cell7: I4   Cell8: I5   Cell9: I6\n *\n * and so on...\n */\n\n/**\n * Initializes a null array for easier resets in the code.\n */\nlet nullArray = [ '0', '0', '0', '0', '0', '0', '0', '0', '0',\n                  '0', '0', '0', '0', '0', '0', '0', '0', '0',\n                  '0', '0', '0', '0', '0', '0', '0', '0', '0',\n                  '0', '0', '0', '0', '0', '0', '0', '0', '0',\n                  '0', '0', '0', '0', '0', '0', '0', '0', '0',\n                  '0', '0', '0', '0', '0', '0', '0', '0', '0',\n                  '0', '0', '0', '0', '0', '0', '0', '0', '0',\n                  '0', '0', '0', '0', '0', '0', '0', '0', '0',\n                  '0', '0', '0', '0', '0', '0', '0', '0', '0' ];\n\n/**\n * Gets the coordinates of the center cell of the specified box.\n */\nfunction _getBoxCenter(box: number) {\n  // eslint-disable-next-line\n  switch(box) {\n    case 0: return [1,1];\n    case 1: return [1,4];\n    case 2: return [1,7];\n    case 3: return [4,1];\n    case 4: return [4,4];\n    case 5: return [4,7];\n    case 6: return [7,1];\n    case 7: return [7,4];\n    default: return [7,7];\n  }\n}\n\n/**\n * Gets the index of cell given:\n * 1. Box\n * 2. Cell\n */\nfunction _getIndexOfCell(box: number, cell: number) {\n  let [row, column] = _getBoxCenter(box);\n  // eslint-disable-next-line\n  switch(cell) {\n    case 0: {row--; column--; break;}\n    case 1: {row--; break;}\n    case 2: {row--; column++; break;}\n    case 3: {column--; break;}\n    case 4: {break;}\n    case 5: {column++; break;}\n    case 6: {row++; column--; break;}\n    case 7: {row++; break;}\n    case 8: {row++; column++; break;}\n  }\n  return row * 9 + column;\n}\n\n/**\n * Checks if Cell is available or not (i.e., filled).\n */\nfunction _cellAvailable(tempInitArray: string[], box: number, value: number) {\n  return tempInitArray[_getIndexOfCell(box, value)] === '0' ? 0 : 1;\n}\n\n/**\n * Generates a Unique Sudoku puzzle from a solved Sudoku.\n */\nfunction _generateUniqueSudoku(solvedArray: string[], difficulty: string, e?: React.ChangeEvent<HTMLSelectElement>) {\n  let currentDifficulty = difficulty;\n  let minimumCells, maximumCells, totalCells, box, cell;\n\n  let tempInitArray = nullArray.slice();\n  let boxCounts = [ 0,0,0,\n                    0,0,0,\n                    0,0,0 ];\n  let boxesAvailable = [];\n  let cellsAvailable = [];\n\n  if (e)\n    currentDifficulty = e.target.value;\n\n  if (currentDifficulty === 'Easy') {\n    minimumCells = 3;\n    maximumCells = 7;\n    totalCells = 45;\n  }\n  else if (currentDifficulty === 'Medium') {\n    minimumCells = 2;\n    maximumCells = 6;\n    totalCells = 40;\n  }\n  else {\n    minimumCells = 1;\n    maximumCells = 5;\n    totalCells = 30;\n  }\n\n  for (let j = 0; j < 9; j++) {\n    boxCounts[j] =  _cellAvailable(tempInitArray, j, 0) +\n                    _cellAvailable(tempInitArray, j, 1) +\n                    _cellAvailable(tempInitArray, j, 2) +\n                    _cellAvailable(tempInitArray, j, 3) +\n                    _cellAvailable(tempInitArray, j, 4) +\n                    _cellAvailable(tempInitArray, j, 5) +\n                    _cellAvailable(tempInitArray, j, 6) +\n                    _cellAvailable(tempInitArray, j, 7) +\n                    _cellAvailable(tempInitArray, j, 8);\n  }\n\n  for (let i = 0; i < totalCells; i++) {\n    boxesAvailable = [];\n    for (let j = 0; j < 9; j++) {\n      if (boxCounts[j] < minimumCells) {\n        boxesAvailable.push(j);\n      }\n    }\n    if (boxesAvailable) {\n      for (let j = 0; j < 9; j++) {\n        if (boxCounts[j] < maximumCells) {\n          boxesAvailable.push(j);\n        }\n      }\n    }\n    box = boxesAvailable[Math.random() * boxesAvailable.length | 0];\n\n    cellsAvailable = [];\n    for (let j = 0; j < 9; j++) {\n      if ( tempInitArray[_getIndexOfCell(box, j)] === '0') {\n        cellsAvailable.push(j);\n      }\n    }\n    cell = cellsAvailable[Math.random() * cellsAvailable.length | 0];\n\n    let index = _getIndexOfCell(box, cell);\n    tempInitArray[index] = solvedArray[index]\n    boxCounts[box]++;\n  }\n\n  return tempInitArray;\n}\n\nexport const getUniqueSudoku = (difficulty: string, e?: React.ChangeEvent<HTMLSelectElement>) => {\n  let temporaryInitArray = nullArray.slice();\n  let temporarySolvedArray = nullArray.slice();\n  let sudoku = getSudoku();\n\n  /**\n   * Get Sudoku from sudoku.js\n   */\n  let str = sudoku.generate(60);\n\n  [...str].forEach((value, index) => {\n    temporaryInitArray[index] = value === '.'\n                        ? '0'\n                        : value;\n  });\n\n  /**\n   * Get the solution from sudoku.js\n   */\n  str = sudoku.solve(str);\n  [...str].forEach((value, index) => {\n    temporarySolvedArray[index] = value;\n  });\n\n  /**\n   * Pass the generated solution and get a unique Sudoku from it!\n   */\n  temporaryInitArray = _generateUniqueSudoku(temporarySolvedArray, difficulty, e);\n\n  return [temporaryInitArray, temporarySolvedArray];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}